<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VISION AI Annotation v9.0</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,sans-serif;background:#0d1117;color:#c9d1d9;overflow:hidden}
.container{display:flex;height:100vh}
.sidebar{width:280px;background:#161b22;padding:14px;overflow-y:auto;border-right:1px solid #30363d}
.sidebar h2{font-size:14px;color:#58a6ff;margin-bottom:14px}
.section{margin-bottom:14px;padding-bottom:10px;border-bottom:1px solid #30363d}
.section-title{font-size:10px;color:#8b949e;text-transform:uppercase;margin-bottom:6px}
select,button,input[type=file]{width:100%;padding:8px;border:1px solid #30363d;border-radius:6px;background:#0d1117;color:#c9d1d9;font-size:11px;margin-bottom:4px}
button{cursor:pointer;font-weight:600;border:none}
button:hover{filter:brightness(1.2)}
button.primary{background:#238636}
button.ai{background:#8957e5}
button.danger{background:#da3633}
button.warning{background:#9e6a03}
button.secondary{background:#30363d}
button.active{box-shadow:0 0 0 2px #1f6feb}
button:disabled{opacity:0.4;cursor:not-allowed}
.btn-row{display:flex;gap:4px}.btn-row button{flex:1}
.status-box{background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:10px;margin-top:6px}
.status-box .label{font-size:9px;color:#8b949e}.status-box .value{font-size:12px;color:#58a6ff;font-weight:bold}
.slider-row{display:flex;align-items:center;gap:8px;margin:6px 0}
.slider-row input[type=range]{flex:1}.slider-row span{min-width:25px;font-size:11px;color:#58a6ff}
.main{flex:1;display:flex;flex-direction:column}
.toolbar{background:#161b22;padding:8px 12px;display:flex;align-items:center;gap:16px;border-bottom:1px solid #30363d;font-size:11px}
.toolbar .mode-badge{padding:4px 10px;border-radius:4px;font-weight:bold;font-size:10px}
.toolbar .mode-badge.bbox{background:#9e6a03}
.toolbar .mode-badge.brush{background:#238636}
.toolbar .mode-badge.eraser{background:#da3633}
.toolbar span{color:#8b949e}.toolbar b{color:#58a6ff}
.canvas-area{flex:1;position:relative;overflow:hidden;background:#010409}
#canvas{position:absolute;cursor:crosshair}
.panel{width:260px;background:#161b22;padding:14px;overflow-y:auto;border-left:1px solid #30363d}
.panel h3{font-size:13px;color:#58a6ff;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center}
.panel h3 .count{font-size:11px;background:#30363d;padding:2px 8px;border-radius:10px}
.work-status{background:#0d1117;border:2px solid #1f6feb;border-radius:8px;padding:12px;margin-bottom:12px}
.work-status .step{padding:6px 8px;border-radius:4px;margin:4px 0;font-size:11px}
.work-status .step.done{background:#238636;color:#fff}
.work-status .step.active{background:#1f6feb;color:#fff}
.work-status .step.pending{background:#30363d;color:#8b949e}
.anno-item{background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;margin-bottom:6px;font-size:10px}
.anno-item .title{font-weight:bold;color:#c9d1d9}.anno-item .meta{color:#8b949e}
.anno-item .badge{display:inline-block;padding:2px 6px;border-radius:3px;font-size:9px;margin-right:4px}
.anno-item .badge.ai{background:#8957e555;color:#a371f7}
.anno-item .badge.manual{background:#1f6feb55;color:#58a6ff}
.anno-item .badge.multi{background:#22c55555;color:#22c55e}

/* ì €ì¥ ê¸°ë¡ ìŠ¤íƒ€ì¼ */
.saved-item{background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;margin-bottom:6px;font-size:10px;position:relative}
.saved-item:hover{border-color:#58a6ff}
.saved-item .filename{font-weight:bold;color:#58a6ff;word-break:break-all}
.saved-item .info{color:#8b949e;margin-top:4px}
.saved-item .info span{margin-right:8px}
.saved-item .delete-btn{position:absolute;top:6px;right:6px;background:#da3633;border:none;color:#fff;width:20px;height:20px;border-radius:4px;cursor:pointer;font-size:12px;display:flex;align-items:center;justify-content:center;opacity:0.7}
.saved-item .delete-btn:hover{opacity:1}
.saved-item.deleting{opacity:0.5;pointer-events:none}

.toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);padding:10px 24px;border-radius:6px;font-size:12px;font-weight:600;display:none;z-index:1000}
.toast.show{display:block}.toast.success{background:#238636}.toast.error{background:#da3633}.toast.info{background:#1f6feb}
.loading{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;justify-content:center;align-items:center;z-index:2000}
.loading.show{display:flex}
.spinner{width:40px;height:40px;border:3px solid #30363d;border-top-color:#8957e5;border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* ì„œë²„ ì´ë¯¸ì§€ ì„ íƒ ëª¨ë‹¬ */
.img-modal-bg{position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;justify-content:center;align-items:center;z-index:3000}
.img-modal-bg.show{display:flex}
.img-modal{background:#161b22;border:1px solid #30363d;border-radius:12px;padding:20px;width:480px;max-height:70vh;display:flex;flex-direction:column}
.img-modal h3{color:#58a6ff;font-size:14px;margin-bottom:10px;flex-shrink:0}
.img-modal .search-row{display:flex;gap:6px;margin-bottom:10px;flex-shrink:0}
.img-modal .search-row input{flex:1;padding:6px 8px;border:1px solid #30363d;border-radius:6px;background:#0d1117;color:#c9d1d9;font-size:11px}
.img-modal .search-row button{padding:6px 10px;font-size:11px}
.img-list{flex:1;overflow-y:auto;border:1px solid #30363d;border-radius:6px}
.img-list-item{padding:8px 10px;border-bottom:1px solid #21262d;cursor:pointer;font-size:11px;display:flex;justify-content:space-between;align-items:center}
.img-list-item:hover{background:#1f6feb22}
.img-list-item.annotated{color:#8b949e}
.img-list-item .badge-ann{background:#238636;color:#fff;font-size:9px;padding:2px 5px;border-radius:3px}
.img-list-item .badge-new{background:#30363d;color:#8b949e;font-size:9px;padding:2px 5px;border-radius:3px}
.img-modal .footer{margin-top:10px;flex-shrink:0;display:flex;justify-content:flex-end;gap:6px}
.server-badge{display:inline-block;background:#1f6feb;color:#fff;font-size:9px;padding:2px 6px;border-radius:3px;margin-left:4px}

/* í™•ì¸ ëª¨ë‹¬ */
.modal-bg{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;justify-content:center;align-items:center;z-index:2000}
.modal-bg.show{display:flex}
.modal{background:#161b22;border:1px solid #30363d;border-radius:12px;padding:20px;max-width:400px;text-align:center}
.modal h3{color:#da3633;margin-bottom:12px}
.modal p{color:#8b949e;margin-bottom:16px;font-size:12px}
.modal .filename{color:#58a6ff;font-weight:bold}
.modal .btn-row{margin-top:16px}

/* íƒ­ ìŠ¤íƒ€ì¼ */
.tabs{display:flex;gap:4px;margin-bottom:10px}
.tab{flex:1;padding:6px;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#8b949e;font-size:10px;cursor:pointer;text-align:center}
.tab.active{background:#1f6feb;border-color:#1f6feb;color:#fff}
.tab-content{display:none}
.tab-content.active{display:block}
</style>
</head>
<body>
<div class="container">
<div class="sidebar">
<h2>ğŸ¤– VISION AI Annotation v9.0</h2>
<div id="serverConfigBanner" style="background:#0d1117;border:1px solid #1f6feb;border-radius:6px;padding:8px;margin-bottom:10px;font-size:10px;color:#58a6ff"></div>
<div class="section">
<div class="section-title">0. ì„œë²„ ì´ë¯¸ì§€ ì„ íƒ</div>
<button class="primary" onclick="openImgModal()" style="margin-bottom:4px">ğŸ“‚ ì„œë²„ ì´ë¯¸ì§€ ëª©ë¡</button>
<div id="serverImageInfo" style="display:none;background:#0d1117;border:1px solid #30363d;border-radius:6px;padding:8px;font-size:10px">
  <div style="color:#8b949e">ì„ íƒëœ íŒŒì¼</div>
  <div id="serverImageName" style="color:#58a6ff;word-break:break-all"></div>
  <span class="server-badge">ì„œë²„ ì´ë¯¸ì§€</span>
</div>
</div>
<div class="section">
<div class="section-title">1. ì§ì ‘ ì—…ë¡œë“œ</div>
<input type="file" id="fileInput" accept="image/*">
<div class="status-box" id="fileInfo" style="display:none">
<div class="label">íŒŒì¼</div><div class="value" id="fileName">-</div>
<div class="label">í¬ê¸°</div><div class="value" id="fileSize">-</div>
</div>
</div>
<div class="section">
<div class="section-title">2. í´ë˜ìŠ¤ ì„ íƒ</div>
<select id="domainSelect"><option value="">ë„ë©”ì¸ ì„ íƒ</option></select>
<select id="classSelect"><option value="">í´ë˜ìŠ¤ ì„ íƒ</option></select>
</div>
<div class="section">
<div class="section-title">3. ê·¸ë¦¬ê¸° ëª¨ë“œ</div>
<div class="btn-row">
<button id="btnBbox" class="warning" onclick="setMode('bbox')">â¬œ BBox</button>
<button id="btnBrush" class="primary" onclick="setMode('brush')">ğŸ–Œï¸ Brush</button>
<button id="btnEraser" class="danger" onclick="setMode('eraser')">ğŸ§¹ ì§€ìš°ê°œ</button>
</div>
<div style="margin-top:8px">
<button id="btnAiSeg" class="ai" onclick="runAI()" disabled>ğŸ¤– AI Segment</button>
</div>
<div class="slider-row">
<span style="color:#8b949e">í¬ê¸°</span>
<input type="range" id="brushSize" min="1" max="50" value="10">
<span id="brushSizeVal">10</span>
</div>
</div>
<div class="section">
<div class="section-title">4. ì‘ì—…</div>
<button class="primary" onclick="finish()">âœ… í˜„ì¬ ê²°í•¨ ì™„ì„±</button>
<button class="warning" onclick="clearCurrent()">ğŸ—‘ï¸ í˜„ì¬ ì‘ì—… ì·¨ì†Œ</button>
<button class="secondary" onclick="undo()">â†©ï¸ Undo (Ctrl+Z)</button>
</div>
<div class="section">
<div class="section-title">5. ì €ì¥</div>
<button class="primary" onclick="saveCurrentImage()" id="btnSave">ğŸ’¾ í˜„ì¬ ì´ë¯¸ì§€ ì €ì¥</button>
<button class="secondary" onclick="downloadJson()">ğŸ“¥ JSON ë‹¤ìš´ë¡œë“œ</button>
</div>
<div class="section">
<div class="status-box"><div class="label">ì„œë²„ ì´ê³„</div><div class="value" id="serverStats">-</div></div>
<div class="status-box"><div class="label">í˜„ì¬ ë§ˆìŠ¤í¬</div><div class="value" id="maskStats">0 px (0ê°œ ì˜ì—­)</div></div>
</div>
</div>

<div class="main">
<div class="toolbar">
<span class="mode-badge bbox" id="modeBadge">â¬œ BBox</span>
<span>ì¢Œí‘œ: <b id="coordsDisp">0, 0</b></span>
<span>í™•ëŒ€: <b id="zoomDisp">100%</b></span>
<span style="margin-left:auto">ì„¸ì…˜: <b id="sessionCount">0</b>ì¥ ì €ì¥ë¨</span>
</div>
<div class="canvas-area" id="canvasArea">
<canvas id="canvas"></canvas>
</div>
</div>

<div class="panel">
<!-- íƒ­ -->
<div class="tabs">
<div class="tab active" onclick="switchTab('current')">ğŸ“‹ í˜„ì¬ ì‘ì—…</div>
<div class="tab" onclick="switchTab('saved')">ğŸ’¾ ì €ì¥ ê¸°ë¡</div>
</div>

<!-- í˜„ì¬ ì‘ì—… íƒ­ -->
<div id="tabCurrent" class="tab-content active">
<div class="work-status">
<div class="step pending" id="step1">1. í´ë˜ìŠ¤ ì„ íƒ</div>
<div class="step pending" id="step2">2. BBox ê·¸ë¦¬ê¸°</div>
<div class="step pending" id="step3">3. Segmentation</div>
<div class="step pending" id="step4">4. ì™„ì„±</div>
</div>
<h3>ğŸ“¦ Annotations <span class="count" id="annoCount">0</span></h3>
<div id="annoList"></div>
</div>

<!-- ì €ì¥ ê¸°ë¡ íƒ­ -->
<div id="tabSaved" class="tab-content">
<h3>ğŸ’¾ ì´ë²ˆ ì„¸ì…˜ ì €ì¥ ê¸°ë¡ <span class="count" id="savedCount">0</span></h3>
<div id="savedList">
<div style="color:#8b949e;font-size:11px;padding:8px">ì €ì¥ëœ ì´ë¯¸ì§€ ì—†ìŒ</div>
</div>
</div>
</div>
</div>

<div class="toast" id="toast"></div>
<div class="loading" id="loading"><div class="spinner"></div></div>

<!-- ì„œë²„ ì´ë¯¸ì§€ ì„ íƒ ëª¨ë‹¬ -->
<div class="img-modal-bg" id="imgModal">
<div class="img-modal">
  <h3>ğŸ“‚ ì„œë²„ ì´ë¯¸ì§€ ì„ íƒ <span id="imgModalCount" style="font-size:11px;color:#8b949e"></span></h3>
  <div class="search-row">
    <input type="text" id="imgSearchInput" placeholder="íŒŒì¼ëª… ê²€ìƒ‰..." oninput="filterImgList()">
    <button class="secondary" onclick="refreshImgList()">ìƒˆë¡œê³ ì¹¨</button>
  </div>
  <div class="img-list" id="imgList">
    <div style="color:#8b949e;font-size:11px;padding:12px;text-align:center">ë¡œë”© ì¤‘...</div>
  </div>
  <div class="footer">
    <button class="secondary" onclick="closeImgModal()">ë‹«ê¸°</button>
  </div>
</div>
</div>

<!-- ì‚­ì œ í™•ì¸ ëª¨ë‹¬ -->
<div class="modal-bg" id="deleteModal">
<div class="modal">
<h3>âš ï¸ ì‚­ì œ í™•ì¸</h3>
<p>ì •ë§ ì´ ì´ë¯¸ì§€ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?<br><span class="filename" id="deleteFileName">-</span></p>
<p style="color:#da3633;font-size:11px">ì´ë¯¸ì§€ íŒŒì¼ê³¼ JSONì˜ ê´€ë ¨ annotationì´ ëª¨ë‘ ì‚­ì œë©ë‹ˆë‹¤.</p>
<div class="btn-row">
<button class="secondary" onclick="closeDeleteModal()">ì·¨ì†Œ</button>
<button class="danger" onclick="confirmDelete()">ì‚­ì œ</button>
</div>
</div>
</div>

<script>
// ============================================================
// v5.6: ë‹¤ì¤‘ ë¶„ë¦¬ ì˜ì—­ segmentation ì§€ì›
// ============================================================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const canvasArea = document.getElementById('canvasArea');

// ì´ë¯¸ì§€ ê´€ë ¨
let img = null;
let imgW = 0, imgH = 0;
let currentImageData = null;
let currentFileName = null;

// ë·° ë³€í™˜
let scale = 1, panX = 0, panY = 0;

// ëª¨ë“œ ë° ìƒíƒœ
let mode = 'bbox';
let drawing = false;
let panning = false;
let lastPan = null;

// BBox
let currentBbox = null;
let tempBbox = null;
let bboxStart = null;
// ============================================================
// BBox ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
// ============================================================
let resizingBbox = false;
let resizeHandle = null;
let bboxDragging = false;
let dragStart = null;

function getBboxHandles(bbox, size) {
    const {x, y, w, h} = bbox;
    return [
        {type: 'tl', x: x, y: y},
        {type: 't', x: x + w/2, y: y},
        {type: 'tr', x: x + w, y: y},
        {type: 'l', x: x, y: y + h/2},
        {type: 'r', x: x + w, y: y + h/2},
        {type: 'bl', x: x, y: y + h},
        {type: 'b', x: x + w/2, y: y + h},
        {type: 'br', x: x + w, y: y + h}
    ];
}

function getHandleAtPoint(px, py) {
    if (!currentBbox) return null;
    const handleSize = 12 / scale;
    const handles = getBboxHandles(currentBbox, handleSize);
    for (const h of handles) {
        if (Math.abs(px - h.x) < handleSize && Math.abs(py - h.y) < handleSize) {
            return h.type;
        }
    }
    return null;
}

function isInsideBbox(px, py) {
    if (!currentBbox) return false;
    const {x, y, w, h} = currentBbox;
    return px >= x && px <= x + w && py >= y && py <= y + h;
}

function updateCursor(px, py) {
    if (!currentBbox) {
        canvas.style.cursor = 'crosshair';
        return;
    }
    const handle = getHandleAtPoint(px, py);
    if (handle) {
        if (handle === 'tl' || handle === 'br') canvas.style.cursor = 'nwse-resize';
        else if (handle === 'tr' || handle === 'bl') canvas.style.cursor = 'nesw-resize';
        else if (handle === 't' || handle === 'b') canvas.style.cursor = 'ns-resize';
        else if (handle === 'l' || handle === 'r') canvas.style.cursor = 'ew-resize';
    } else if (isInsideBbox(px, py) && mode === 'bbox') {
        canvas.style.cursor = 'move';
    } else {
        canvas.style.cursor = 'crosshair';
    }
}

// ë§ˆìŠ¤í¬
let mask = null;
let lastBrushPos = null;


// Annotations
let annotations = [];
let undoStack = [];
let aiConfidence = 0;
let restoredAnnotation = null;

// â˜… ì €ì¥ ê¸°ë¡
let savedImages = [];
let deleteTarget = null;

const categories = {{ CATEGORIES_JSON | safe }};
const serverConfig = {{ SERVER_CONFIG | safe }};

// ì„œë²„ ì´ë¯¸ì§€ ê´€ë ¨
let isServerImage = false;      // í˜„ì¬ ì´ë¯¸ì§€ê°€ ì„œë²„ì—ì„œ ë¡œë“œëœ ê²ƒì¸ì§€
let serverImageFilename = null; // ì„œë²„ ì´ë¯¸ì§€ íŒŒì¼ëª…
let serverImageCategory = null; // ì„œë²„ ì´ë¯¸ì§€ ì¹´í…Œê³ ë¦¬
let allServerFiles = [];        // ì„œë²„ ì´ë¯¸ì§€ ëª©ë¡ ìºì‹œ

// ============================================================
// ì´ˆê¸°í™”
// ============================================================
window.onload = () => {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    document.getElementById('fileInput').addEventListener('change', loadImage);
    document.getElementById('domainSelect').addEventListener('change', loadClasses);
    document.getElementById('brushSize').addEventListener('input', e => {
        document.getElementById('brushSizeVal').textContent = e.target.value;
    });

    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('mouseleave', onMouseLeave);
    canvas.addEventListener('wheel', onWheel, { passive: false });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    document.addEventListener('keydown', onKeyDown);

    loadDomains();
    loadServerInfo();
    setMode('bbox');
    render();

    // ì„œë²„ ì„¤ì • ë°°ë„ˆ í‘œì‹œ
    const banner = document.getElementById('serverConfigBanner');
    if (banner && serverConfig) {
        const catLabel = serverConfig.category === 'all' ? 'ì „ì²´ (Cable + Screw + Casting)' : serverConfig.category;
        banner.textContent = `ì¹´í…Œê³ ë¦¬: ${catLabel}  |  Split: ${serverConfig.split}`;
    }
};

function resizeCanvas() {
    canvas.width = canvasArea.clientWidth;
    canvas.height = canvasArea.clientHeight;
    render();
}

// ============================================================
// íƒ­ ì „í™˜
// ============================================================
function switchTab(tab) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    if (tab === 'current') {
        document.querySelectorAll('.tab')[0].classList.add('active');
        document.getElementById('tabCurrent').classList.add('active');
    } else {
        document.querySelectorAll('.tab')[1].classList.add('active');
        document.getElementById('tabSaved').classList.add('active');
    }
}

// ============================================================
// ì¢Œí‘œ ë³€í™˜
// ============================================================
function screenToImage(sx, sy) {
    return { x: (sx - panX) / scale, y: (sy - panY) / scale };
}

// ============================================================
// íŒŒì¼ ë¡œë“œ
// ============================================================
function loadDomains() {
    const sel = document.getElementById('domainSelect');
    sel.innerHTML = '<option value="">ë„ë©”ì¸ ì„ íƒ</option>';
    Object.keys(categories).forEach(d => {
        sel.innerHTML += `<option value="${d}">${d}</option>`;
    });
}

function loadClasses() {
    const domain = document.getElementById('domainSelect').value;
    const sel = document.getElementById('classSelect');
    sel.innerHTML = '<option value="">í´ë˜ìŠ¤ ì„ íƒ</option>';
    if (domain && categories[domain]) {
        categories[domain].forEach(c => {
            sel.innerHTML += `<option value='${JSON.stringify(c)}'>${c.name}</option>`;
        });
    }
    updateStatus();
}

function loadServerInfo() {
    fetch('/info').then(r => r.json())
        .then(d => {
            document.getElementById('serverStats').textContent = 
                d.num_images + 'ì¥, ' + d.num_annotations + 'ê°œ';
        })
        .catch(() => {
            document.getElementById('serverStats').textContent = 'ì—°ê²° ì‹¤íŒ¨';
        });
}

function loadImage(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (ev) => {
        img = new Image();
        img.onload = () => {
            imgW = img.width;
            imgH = img.height;
            
            currentImageData = ev.target.result;
            currentFileName = file.name;
            
            mask = null;
            currentBbox = null;
            tempBbox = null;
            annotations = [];
            undoStack = [];
            lastBrushPos = null;
            aiConfidence = 0;
            
            fitView();
            
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = imgW + ' Ã— ' + imgH;
            
            for (const d of Object.keys(categories)) {
                if (file.name.toLowerCase().includes(d.toLowerCase())) {
                    document.getElementById('domainSelect').value = d;
                    loadClasses();
                    break;
                }
            }
            
            updateAll();
            render();
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
}

// ============================================================
// ì„œë²„ ì´ë¯¸ì§€ ë¸Œë¼ìš°ì§•
// ============================================================
async function openImgModal() {
    document.getElementById('imgModal').classList.add('show');
    await refreshImgList();
}

function closeImgModal() {
    document.getElementById('imgModal').classList.remove('show');
}

async function refreshImgList() {
    document.getElementById('imgList').innerHTML =
        '<div style="color:#8b949e;font-size:11px;padding:12px;text-align:center">ë¡œë”© ì¤‘...</div>';
    try {
        const res = await fetch('/images/list');
        const data = await res.json();
        allServerFiles = data.files || [];
        document.getElementById('imgModalCount').textContent =
            `(ì „ì²´ ${data.total}ì¥ / ë¼ë²¨ë§ë¨ ${data.annotated}ì¥)`;
        renderImgList(allServerFiles);
    } catch (e) {
        document.getElementById('imgList').innerHTML =
            `<div style="color:#da3633;font-size:11px;padding:12px">ì˜¤ë¥˜: ${e.message}</div>`;
    }
}

function filterImgList() {
    const q = document.getElementById('imgSearchInput').value.toLowerCase();
    const filtered = q ? allServerFiles.filter(f => f.name.toLowerCase().includes(q)) : allServerFiles;
    renderImgList(filtered);
}

function renderImgList(files) {
    const list = document.getElementById('imgList');
    if (!files.length) {
        list.innerHTML = '<div style="color:#8b949e;font-size:11px;padding:12px;text-align:center">ì´ë¯¸ì§€ ì—†ìŒ</div>';
        return;
    }
    list.innerHTML = files.map(f => `
        <div class="img-list-item ${f.annotated ? 'annotated' : ''}" onclick="selectServerImage('${f.name}', '${f.category || ''}')">
            <span>${f.name}</span>
            <span style="font-size:9px;color:#8b949e;margin-right:4px">[${f.category || ''}]</span>
            <span class="badge-${f.annotated ? 'ann' : 'new'}">${f.annotated ? 'ë¼ë²¨ë¨' : 'ë¯¸ë¼ë²¨'}</span>
        </div>
    `).join('');
}

async function selectServerImage(filename, category) {
    closeImgModal();
    document.getElementById('loading').classList.add('show');

    try {
        // ì´ë¯¸ì§€ ë¡œë“œ
        const imgUrl = `/images/serve/${encodeURIComponent(filename)}`;
        await new Promise((resolve, reject) => {
            const newImg = new Image();
            newImg.onload = () => {
                img = newImg;
                imgW = newImg.width;
                imgH = newImg.height;
                currentImageData = imgUrl;
                currentFileName = filename;
                isServerImage = true;
                serverImageFilename = filename;
                serverImageCategory = category || null;
                resolve();
            };
            newImg.onerror = reject;
            newImg.src = imgUrl + '?t=' + Date.now();
        });

        // ìƒíƒœ ì´ˆê¸°í™”
        mask = null; currentBbox = null; tempBbox = null;
        annotations = []; undoStack = []; lastBrushPos = null; aiConfidence = 0;

        fitView();

        // ì„œë²„ ì´ë¯¸ì§€ ì •ë³´ í‘œì‹œ
        document.getElementById('serverImageInfo').style.display = 'block';
        document.getElementById('serverImageName').textContent = filename;
        document.getElementById('fileInfo').style.display = 'block';
        document.getElementById('fileName').textContent = filename;
        document.getElementById('fileSize').textContent = imgW + ' Ã— ' + imgH;

        // ë„ë©”ì¸ ìë™ ì„ íƒ (category ìš°ì„ , ì—†ìœ¼ë©´ íŒŒì¼ëª…ìœ¼ë¡œ ì¶”ì¸¡)
        const matchDomain = category || Object.keys(categories).find(
            d => filename.toLowerCase().startsWith(d.toLowerCase())
        );
        if (matchDomain && categories[matchDomain]) {
            document.getElementById('domainSelect').value = matchDomain;
        } else {
            document.getElementById('domainSelect').value = Object.keys(categories)[0];
        }
        loadClasses();

        // ê¸°ì¡´ annotations ë¡œë“œ
        const annRes = await fetch(`/annotations/for/${encodeURIComponent(filename)}`);
        const annData = await annRes.json();
        if (annData.found && annData.annotations.length > 0) {
            // COCO annotations â†’ í”„ë¡ íŠ¸ì—”ë“œ í¬ë§·ìœ¼ë¡œ ë³€í™˜
            const catMap = {};
            for (const d of Object.keys(categories)) {
                for (const c of categories[d]) { catMap[c.id] = c.name; }
            }
            annotations = annData.annotations.map((a, i) => ({
                id: i + 1,
                category_id: a.category_id,
                category_name: catMap[a.category_id] || '?',
                bbox: a.bbox,
                segmentation: a.segmentation || [],
                area: a.area || 0,
                iscrowd: a.iscrowd || 0,
                ai: false,
                regionCount: (a.segmentation || []).length,
            }));
            toast(`ê¸°ì¡´ annotation ${annotations.length}ê°œ ë¡œë“œë¨`, 'info');
        }

        updateAll();
        render();
    } catch (e) {
        toast('ì´ë¯¸ì§€ ë¡œë“œ ì˜¤ë¥˜: ' + e.message, 'error');
        console.error(e);
    } finally {
        document.getElementById('loading').classList.remove('show');
    }
}

function fitView() {
    const pad = 50;
    const availW = canvasArea.clientWidth - pad * 2;
    const availH = canvasArea.clientHeight - pad * 2;
    
    scale = Math.min(availW / imgW, availH / imgH, 1);
    panX = (canvasArea.clientWidth - imgW * scale) / 2;
    panY = (canvasArea.clientHeight - imgH * scale) / 2;
    
    document.getElementById('zoomDisp').textContent = Math.round(scale * 100) + '%';
}

// ============================================================
// ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
// ============================================================
function onMouseDown(e) {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    
    if (e.button === 2) {
        panning = true;
        lastPan = { x: sx, y: sy };
        canvas.style.cursor = 'grabbing';
        return;
    }
    
    if (e.button === 0 && img) {
        const p = screenToImage(sx, sy);
        if (p.x < 0 || p.x >= imgW || p.y < 0 || p.y >= imgH) return;
        
        const ix = Math.floor(p.x);
        const iy = Math.floor(p.y);
        
        if (mode === 'bbox') {
            const handle = getHandleAtPoint(p.x, p.y);
            if (handle) {
                resizingBbox = true;
                resizeHandle = handle;
                return;
            }
            
            if (isInsideBbox(p.x, p.y)) {
                bboxDragging = true;
                dragStart = { x: p.x, y: p.y, bbox: {...currentBbox} };
                return;
            }
            
            drawing = true;
            bboxStart = { x: p.x, y: p.y };
            tempBbox = null;
        } 
        else if (mode === 'brush') {
            saveUndo();
            if (!mask) mask = new Uint8Array(imgW * imgH);
            drawing = true;
            lastBrushPos = { x: ix, y: iy };
            paintCircle(ix, iy, true);
            render();
        }
        else if (mode === 'eraser') {
            if (mask) {
                saveUndo();
                drawing = true;
                lastBrushPos = { x: ix, y: iy };
                paintCircle(ix, iy, false);
                render();
            }
        }
    }
}

function onMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const p = screenToImage(sx, sy);
    
    document.getElementById('coordsDisp').textContent = 
        Math.floor(p.x) + ', ' + Math.floor(p.y);
    
    if (!drawing && !resizingBbox && !bboxDragging && !panning) {
        updateCursor(p.x, p.y);
    }
    
    if (panning && lastPan) {
        panX += sx - lastPan.x;
        panY += sy - lastPan.y;
        lastPan = { x: sx, y: sy };
        render();
        return;
    }
    
    if (resizingBbox && currentBbox && resizeHandle) {
        const {x, y, w, h} = currentBbox;
        
        switch(resizeHandle) {
            case 'tl':
                currentBbox.w = x + w - p.x;
                currentBbox.h = y + h - p.y;
                currentBbox.x = p.x;
                currentBbox.y = p.y;
                break;
            case 'tr':
                currentBbox.w = p.x - x;
                currentBbox.h = y + h - p.y;
                currentBbox.y = p.y;
                break;
            case 'bl':
                currentBbox.w = x + w - p.x;
                currentBbox.h = p.y - y;
                currentBbox.x = p.x;
                break;
            case 'br':
                currentBbox.w = p.x - x;
                currentBbox.h = p.y - y;
                break;
            case 't':
                currentBbox.h = y + h - p.y;
                currentBbox.y = p.y;
                break;
            case 'b':
                currentBbox.h = p.y - y;
                break;
            case 'l':
                currentBbox.w = x + w - p.x;
                currentBbox.x = p.x;
                break;
            case 'r':
                currentBbox.w = p.x - x;
                break;
        }
        
        if (currentBbox.w < 5) currentBbox.w = 5;
        if (currentBbox.h < 5) currentBbox.h = 5;
        
        render();
        return;
    }
    
    if (bboxDragging && dragStart) {
        const dx = p.x - dragStart.x;
        const dy = p.y - dragStart.y;
        currentBbox.x = dragStart.bbox.x + dx;
        currentBbox.y = dragStart.bbox.y + dy;
        render();
        return;
    }
    
    if (drawing && img) {
        const ix = Math.floor(p.x);
        const iy = Math.floor(p.y);
        
        if (mode === 'bbox' && bboxStart) {
            tempBbox = {
                x: Math.min(bboxStart.x, p.x),
                y: Math.min(bboxStart.y, p.y),
                w: Math.abs(p.x - bboxStart.x),
                h: Math.abs(p.y - bboxStart.y)
            };
            render();
        }
        else if (mode === 'brush' && mask) {
            if (lastBrushPos) {
                paintLine(lastBrushPos.x, lastBrushPos.y, ix, iy, true);
            }
            lastBrushPos = { x: ix, y: iy };
            render();
        }
        else if (mode === 'eraser' && mask) {
            if (lastBrushPos) {
                paintLine(lastBrushPos.x, lastBrushPos.y, ix, iy, false);
            }
            lastBrushPos = { x: ix, y: iy };
            render();
        }
    }
}

function onMouseUp(e) {
    if (e.button === 2) {
        panning = false;
        lastPan = null;
        canvas.style.cursor = 'crosshair';
        return;
    }
    
    if (e.button === 0) {
        if (resizingBbox) {
            resizingBbox = false;
            resizeHandle = null;
            if (currentBbox.w < 0) {
                currentBbox.x += currentBbox.w;
                currentBbox.w = Math.abs(currentBbox.w);
            }
            if (currentBbox.h < 0) {
                currentBbox.y += currentBbox.h;
                currentBbox.h = Math.abs(currentBbox.h);
            }
            currentBbox.x = Math.round(currentBbox.x);
            currentBbox.y = Math.round(currentBbox.y);
            currentBbox.w = Math.round(currentBbox.w);
            currentBbox.h = Math.round(currentBbox.h);
            render();
            return;
        }
        
        if (bboxDragging) {
            bboxDragging = false;
            dragStart = null;
            currentBbox.x = Math.round(currentBbox.x);
            currentBbox.y = Math.round(currentBbox.y);
            render();
            return;
        }
        
        if (drawing) {
            drawing = false;
            lastBrushPos = null;
            
            if (mode === 'bbox' && tempBbox && tempBbox.w > 3 && tempBbox.h > 3) {
                saveUndo();
                currentBbox = {
                    x: Math.round(tempBbox.x),
                    y: Math.round(tempBbox.y),
                    w: Math.round(tempBbox.w),
                    h: Math.round(tempBbox.h)
                };
                tempBbox = null;
                bboxStart = null;
                document.getElementById('btnAiSeg').disabled = false;
                toast('BBox ì„¤ì •ë¨ - ëª¨ì„œë¦¬ë¥¼ ë“œë˜ê·¸í•´ì„œ ìˆ˜ì • ê°€ëŠ¥', 'info');
            }
            
            updateStatus();
            render();
        }
    }
}

function onMouseLeave() {
    drawing = false;
    panning = false;
    resizingBbox = false;
    bboxDragging = false;
    lastBrushPos = null;
    lastPan = null;
    dragStart = null;
    resizeHandle = null;
}

function onWheel(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const zoomFactor = e.deltaY < 0 ? 1.15 : 0.87;
    const newScale = Math.max(0.1, Math.min(10, scale * zoomFactor));
    
    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);
    scale = newScale;
    
    document.getElementById('zoomDisp').textContent = Math.round(scale * 100) + '%';
    render();
}

function onKeyDown(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    if (e.ctrlKey && e.key === 'z') {
        e.preventDefault();
        undo();
        return;
    }
    
    switch (e.key.toLowerCase()) {
        case 'b': setMode('bbox'); break;
        case 'p': case 's': setMode('brush'); break;
        case 'e': setMode('eraser'); break;
        case 'a': runAI(); break;
        case 'enter': finish(); break;
        case 'escape': clearCurrent(); break;
        case 'r': fitView(); render(); break;
        case '[': adjustBrush(-3); break;
        case ']': adjustBrush(3); break;
    }
}

function adjustBrush(delta) {
    const inp = document.getElementById('brushSize');
    inp.value = Math.max(1, Math.min(50, parseInt(inp.value) + delta));
    document.getElementById('brushSizeVal').textContent = inp.value;
}

// ============================================================
// ëª¨ë“œ ì„¤ì •
// ============================================================
function setMode(m) {
    mode = m;
    
    document.getElementById('btnBbox').classList.remove('active');
    document.getElementById('btnBrush').classList.remove('active');
    document.getElementById('btnEraser').classList.remove('active');
    
    if (m === 'bbox') document.getElementById('btnBbox').classList.add('active');
    else if (m === 'brush') document.getElementById('btnBrush').classList.add('active');
    else if (m === 'eraser') document.getElementById('btnEraser').classList.add('active');
    
    const badge = document.getElementById('modeBadge');
    badge.className = 'mode-badge ' + m;
    badge.textContent = m === 'bbox' ? 'â¬œ BBox' : m === 'brush' ? 'ğŸ–Œï¸ Brush' : 'ğŸ§¹ ì§€ìš°ê°œ';
}


// ============================================================
// ë§ˆìŠ¤í¬ ê·¸ë¦¬ê¸°
// ============================================================
function paintCircle(cx, cy, fill) {
    const r = parseInt(document.getElementById('brushSize').value);
    const rSq = r * r;
    
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            if (dx * dx + dy * dy <= rSq) {
                const px = cx + dx;
                const py = cy + dy;
                
                if (px < 0 || px >= imgW || py < 0 || py >= imgH) continue;
                
                if (currentBbox) {
                    if (px < currentBbox.x || px >= currentBbox.x + currentBbox.w ||
                        py < currentBbox.y || py >= currentBbox.y + currentBbox.h) {
                        continue;
                    }
                }
                
                mask[py * imgW + px] = fill ? 1 : 0;
            }
        }
    }
    updateMaskStats();
}

function paintLine(x0, y0, x1, y1, fill) {
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    
    let x = x0, y = y0;
    while (true) {
        paintCircle(x, y, fill);
        if (x === x1 && y === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
    }
}

function updateMaskStats() {
    if (!mask) {
        document.getElementById('maskStats').textContent = '0 px (0ê°œ ì˜ì—­)';
        return;
    }
    let count = 0;
    for (let i = 0; i < mask.length; i++) {
        if (mask[i]) count++;
    }
    // ì˜ì—­ ê°œìˆ˜ë„ í‘œì‹œ
    const polys = maskToPolygon();
    const regionCount = polys ? polys.length : 0;
    document.getElementById('maskStats').textContent = 
        count.toLocaleString() + ' px (' + regionCount + 'ê°œ ì˜ì—­)';
}

// ============================================================
// ë§ˆìŠ¤í¬ â†’ í´ë¦¬ê³¤ ë³€í™˜ (ëª¨ë“  ì—°ê²°ëœ ì˜ì—­ í¬í•¨) - v5.6 ìˆ˜ì •
// ============================================================
function maskToPolygon() {
    if (!mask) return [];
    
    const visited = new Uint8Array(imgW * imgH);
    const allPolygons = [];
    
    for (let y = 0; y < imgH; y++) {
        for (let x = 0; x < imgW; x++) {
            const idx = y * imgW + x;
            if (mask[idx] && !visited[idx]) {
                // BFSë¡œ ì—°ê²°ëœ ì˜ì—­ ì°¾ê¸°
                const region = [];
                const queue = [[x, y]];
                visited[idx] = 1;
                
                while (queue.length > 0) {
                    const [cx, cy] = queue.shift();
                    region.push({x: cx, y: cy});
                    
                    const neighbors = [[cx-1,cy],[cx+1,cy],[cx,cy-1],[cx,cy+1]];
                    for (const [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < imgW && ny >= 0 && ny < imgH) {
                            const nidx = ny * imgW + nx;
                            if (mask[nidx] && !visited[nidx]) {
                                visited[nidx] = 1;
                                queue.push([nx, ny]);
                            }
                        }
                    }
                }
                
                // ìµœì†Œ í”½ì…€ ìˆ˜ (ë…¸ì´ì¦ˆ ì œê±°)
                if (region.length >= 10) {
                    const poly = regionToPolygon(region);
                    if (poly.length >= 6) {
                        allPolygons.push(poly);
                    }
                }
            }
        }
    }
    
    if (allPolygons.length === 0) return [];
    
    // â˜… v5.6: ëª¨ë“  ì˜ì—­ì˜ í´ë¦¬ê³¤ ë°˜í™˜ (í¬ê¸°ìˆœ ì •ë ¬)
    allPolygons.sort((a, b) => b.length - a.length);
    return allPolygons;  // ë°°ì—´ì˜ ë°°ì—´ ë°˜í™˜
}

function regionToPolygon(region) {
    const regionSet = new Set(region.map(p => `${p.x},${p.y}`));
    const edgePixels = [];
    
    for (const p of region) {
        const neighbors = [[p.x-1,p.y],[p.x+1,p.y],[p.x,p.y-1],[p.x,p.y+1]];
        for (const [nx, ny] of neighbors) {
            if (!regionSet.has(`${nx},${ny}`)) {
                edgePixels.push(p);
                break;
            }
        }
    }
    
    if (edgePixels.length < 3) return [];
    
    const contour = traceContour(edgePixels);
    
    const maxPoints = 150;
    const step = Math.max(1, Math.floor(contour.length / maxPoints));
    
    const polygon = [];
    for (let i = 0; i < contour.length; i += step) {
        polygon.push(contour[i].x, contour[i].y);
    }
    
    return polygon;
}

function traceContour(edgePixels) {
    if (edgePixels.length === 0) return [];
    
    const pixelSet = new Set(edgePixels.map(p => `${p.x},${p.y}`));
    const visited = new Set();
    const contour = [];
    
    let start = edgePixels[0];
    for (const p of edgePixels) {
        if (p.y < start.y || (p.y === start.y && p.x < start.x)) {
            start = p;
        }
    }
    
    let current = start;
    const directions = [
        [1, 0], [1, 1], [0, 1], [-1, 1],
        [-1, 0], [-1, -1], [0, -1], [1, -1]
    ];
    let dir = 0;
    
    do {
        contour.push({x: current.x, y: current.y});
        visited.add(`${current.x},${current.y}`);
        
        let found = false;
        for (let i = 0; i < 8; i++) {
            const newDir = (dir + 6 + i) % 8;
            const nx = current.x + directions[newDir][0];
            const ny = current.y + directions[newDir][1];
            const key = `${nx},${ny}`;
            
            if (pixelSet.has(key)) {
                current = {x: nx, y: ny};
                dir = newDir;
                found = true;
                break;
            }
        }
        
        if (!found) break;
        if (contour.length > edgePixels.length * 2) break;
        
    } while (current.x !== start.x || current.y !== start.y);
    
    return contour;
}

// â˜… v5.6: ë‹¤ì¤‘ í´ë¦¬ê³¤ì„ ë§ˆìŠ¤í¬ë¡œ ë³€í™˜
function polygonsToMask(polys) {
    if (!polys || polys.length === 0) return;
    
    mask = new Uint8Array(imgW * imgH);
    
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = imgW;
    tempCanvas.height = imgH;
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCtx.fillStyle = '#fff';
    
    // ëª¨ë“  í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
    for (const poly of polys) {
        if (poly.length < 6) continue;
        tempCtx.beginPath();
        tempCtx.moveTo(poly[0], poly[1]);
        for (let i = 2; i < poly.length; i += 2) {
            tempCtx.lineTo(poly[i], poly[i + 1]);
        }
        tempCtx.closePath();
        tempCtx.fill();
    }
    
    const imageData = tempCtx.getImageData(0, 0, imgW, imgH);
    const data = imageData.data;
    for (let i = 0; i < imgW * imgH; i++) {
        mask[i] = data[i * 4] > 128 ? 1 : 0;
    }
    
    updateMaskStats();
}

// ë‹¨ì¼ í´ë¦¬ê³¤ìš© (AI segment ë“±)
function polygonToMask(poly) {
    polygonsToMask([poly]);
}

// ============================================================
// AI Segment
// ============================================================
async function runAI() {
    if (!currentBbox || !img) {
        toast('ë¨¼ì € BBoxë¥¼ ê·¸ë¦¬ì„¸ìš”', 'error');
        return;
    }
    
    document.getElementById('loading').classList.add('show');
    
    try {
        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = currentBbox.w;
        cropCanvas.height = currentBbox.h;
        const cropCtx = cropCanvas.getContext('2d');
        cropCtx.drawImage(img, 
            currentBbox.x, currentBbox.y, currentBbox.w, currentBbox.h,
            0, 0, currentBbox.w, currentBbox.h);
        
        const response = await fetch('/ai/segment', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                image: cropCanvas.toDataURL('image/jpeg', 0.9).split(',')[1]
            })
        });
        
        const result = await response.json();
        if (result.error) throw new Error(result.error);
        
        const globalPoly = result.polygon.map((v, i) => 
            i % 2 === 0 ? v + currentBbox.x : v + currentBbox.y
        );
        
        polygonToMask(globalPoly);
        aiConfidence = result.confidence;
        
        toast('AI Segment ì™„ë£Œ', 'success');
        updateStatus();
        render();
        
    } catch (e) {
        toast('AI ì˜¤ë¥˜: ' + e.message, 'error');
    } finally {
        document.getElementById('loading').classList.remove('show');
    }
}

// ============================================================
// Undo / Clear
// ============================================================
function saveUndo() {
    undoStack.push({
        bbox: currentBbox ? { ...currentBbox } : null,
        mask: mask ? new Uint8Array(mask) : null,
        annotations: JSON.parse(JSON.stringify(annotations))
    });
    if (undoStack.length > 30) undoStack.shift();
}

function undo() {
    if (undoStack.length === 0) {
        toast('Undoí•  ë‚´ìš© ì—†ìŒ', 'info');
        return;
    }
    
    const state = undoStack.pop();
    currentBbox = state.bbox;
    mask = state.mask;
    annotations = state.annotations;
    
    updateAll();
    render();
    toast('Undo', 'info');
}

function clearCurrent() {
    if (currentBbox || mask) {
        currentBbox = null;
        tempBbox = null;
        bboxStart = null;
        mask = null;
        lastBrushPos = null;
        aiConfidence = 0;
        resizingBbox = false;
        resizeHandle = null;
        bboxDragging = false;
        dragStart = null;
        restoredAnnotation = null;
        
        document.getElementById('btnAiSeg').disabled = true;
        updateAll();
        render();
        toast('í˜„ì¬ ì‘ì—… ì·¨ì†Œë¨', 'info');
        return;
    }
    
    if (annotations.length > 0) {
        const last = annotations.pop();
        
        restoredAnnotation = last;
        
        currentBbox = {
            x: last.bbox[0],
            y: last.bbox[1],
            w: last.bbox[2],
            h: last.bbox[3]
        };
        
        // â˜… v5.6: ë‹¤ì¤‘ í´ë¦¬ê³¤ ë³µì›
        if (last.segmentation && last.segmentation.length > 0) {
            polygonsToMask(last.segmentation);
        }
        
        document.getElementById('btnAiSeg').disabled = false;
        updateAll();
        render();
        toast('ë§ˆì§€ë§‰ annotation ë³µì›ë¨ - ìˆ˜ì • ê°€ëŠ¥', 'info');
    } else {
        toast('ì·¨ì†Œí•  ì‘ì—… ì—†ìŒ', 'info');
    }
}

// ============================================================
// í˜„ì¬ ê²°í•¨ ì™„ì„± - v5.6 ë‹¤ì¤‘ ì˜ì—­ ì§€ì›
// ============================================================
function finish() {
    let cls = null;
    const classData = document.getElementById('classSelect').value;
    
    if (classData) {
        cls = JSON.parse(classData);
    } else if (restoredAnnotation) {
        cls = {
            id: restoredAnnotation.category_id,
            name: restoredAnnotation.category_name
        };
    } else {
        toast('í´ë˜ìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”', 'error');
        return;
    }
    
    if (!currentBbox) {
        toast('BBoxë¥¼ ê·¸ë¦¬ì„¸ìš”', 'error');
        return;
    }
    
    // â˜… v5.6: ë‹¤ì¤‘ í´ë¦¬ê³¤ ì²˜ë¦¬
    const polys = maskToPolygon();  // ë°°ì—´ì˜ ë°°ì—´
    if (!polys || polys.length === 0 || polys[0].length < 6) {
        toast('Segmentationì„ ê·¸ë¦¬ì„¸ìš”', 'error');
        return;
    }
    
    saveUndo();
    
    // â˜… v5.6: ëª¨ë“  í´ë¦¬ê³¤ì˜ ë©´ì  í•©ì‚°
    let totalArea = 0;
    for (const poly of polys) {
        const n = poly.length / 2;
        let area = 0;
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += poly[i * 2] * poly[j * 2 + 1];
            area -= poly[j * 2] * poly[i * 2 + 1];
        }
        totalArea += Math.abs(area / 2);
    }
    totalArea = Math.round(totalArea);
    
    annotations.push({
        id: annotations.length + 1,
        category_id: cls.id,
        category_name: cls.name,
        bbox: [currentBbox.x, currentBbox.y, currentBbox.w, currentBbox.h],
        segmentation: polys,  // â˜… ëª¨ë“  í´ë¦¬ê³¤ ì €ì¥
        area: totalArea,
        iscrowd: 0,
        ai: aiConfidence > 0,
        regionCount: polys.length  // â˜… ì˜ì—­ ê°œìˆ˜ ì €ì¥
    });
    
    currentBbox = null;
    mask = null;
    aiConfidence = 0;
    restoredAnnotation = null;
    
    document.getElementById('btnAiSeg').disabled = true;
    updateAll();
    render();
    toast('âœ“ ' + cls.name + ' ì¶”ê°€ë¨ (' + polys.length + 'ê°œ ì˜ì—­)', 'success');
}

function deleteAnno(idx) {
    saveUndo();
    annotations.splice(idx, 1);
    annotations.forEach((a, i) => a.id = i + 1);
    updateAll();
    render();
}

// ============================================================
// UI ì—…ë°ì´íŠ¸ - v5.6 ìˆ˜ì •
// ============================================================
function updateStatus() {
    const hasClass = !!document.getElementById('classSelect').value;
    const hasBbox = !!currentBbox;
    
    // â˜… v5.6: ë‹¤ì¤‘ í´ë¦¬ê³¤ ì²´í¬
    const polys = maskToPolygon();
    const hasMask = polys && polys.length > 0 && polys[0].length >= 6;
    
    document.getElementById('step1').className = 'step ' + (hasClass ? 'done' : 'active');
    document.getElementById('step2').className = 'step ' + (hasBbox ? 'done' : (hasClass ? 'active' : 'pending'));
    document.getElementById('step3').className = 'step ' + (hasMask ? 'done' : (hasBbox ? 'active' : 'pending'));
    document.getElementById('step4').className = 'step ' + ((hasClass && hasBbox && hasMask) ? 'active' : 'pending');
}

function updateAnnoList() {
    document.getElementById('annoCount').textContent = annotations.length;
    const list = document.getElementById('annoList');
    
    if (annotations.length === 0) {
        list.innerHTML = '<div style="color:#8b949e;font-size:11px;padding:8px">ì—†ìŒ</div>';
        return;
    }
    
    list.innerHTML = annotations.map((a, i) => `
        <div class="anno-item">
            <div class="title">${i + 1}. ${a.category_name}</div>
            <div class="meta">bbox: [${a.bbox.join(', ')}]<br>area: ${a.area.toLocaleString()} pxÂ²</div>
            <span class="badge ${a.ai ? 'ai' : 'manual'}">${a.ai ? 'ğŸ¤– AI' : 'ğŸ–Œï¸ ìˆ˜ë™'}</span>
            ${a.regionCount > 1 ? `<span class="badge multi">ğŸ”— ${a.regionCount}ê°œ ì˜ì—­</span>` : ''}
            <button class="danger" style="padding:4px 8px;font-size:9px;margin-top:6px" onclick="deleteAnno(${i})">ì‚­ì œ</button>
        </div>
    `).join('');
}

function updateSavedList() {
    document.getElementById('savedCount').textContent = savedImages.length;
    document.getElementById('sessionCount').textContent = savedImages.length;
    const list = document.getElementById('savedList');
    
    if (savedImages.length === 0) {
        list.innerHTML = '<div style="color:#8b949e;font-size:11px;padding:8px">ì €ì¥ëœ ì´ë¯¸ì§€ ì—†ìŒ</div>';
        return;
    }
    
    list.innerHTML = savedImages.map((s, i) => `
        <div class="saved-item" id="saved-${i}">
            <button class="delete-btn" onclick="requestDelete(${i})" title="ì‚­ì œ">âœ•</button>
            <div class="filename">${s.file_name}</div>
            <div class="info">
                <span>ğŸ·ï¸ ${s.domain}</span>
                <span>ğŸ“ ${s.anno_count}ê°œ</span>
            </div>
            <div class="info">
                <span>ğŸ• ${s.timestamp}</span>
            </div>
        </div>
    `).join('');
}

function updateAll() {
    updateStatus();
    updateAnnoList();
    updateMaskStats();
    updateSavedList();
}

// ============================================================
// ë Œë”ë§ - v5.6 ë‹¤ì¤‘ í´ë¦¬ê³¤ ë Œë”ë§
// ============================================================
function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!img) {
        ctx.fillStyle = '#8b949e';
        ctx.font = '16px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ì„¸ìš”', canvas.width / 2, canvas.height / 2);
        return;
    }
    
    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(scale, scale);
    
    ctx.drawImage(img, 0, 0);
    
    if (mask) {
        ctx.fillStyle = 'rgba(139, 92, 246, 0.4)';
        for (let y = 0; y < imgH; y++) {
            let startX = -1;
            for (let x = 0; x <= imgW; x++) {
                const filled = x < imgW && mask[y * imgW + x];
                if (filled && startX < 0) {
                    startX = x;
                } else if (!filled && startX >= 0) {
                    ctx.fillRect(startX, y, x - startX, 1);
                    startX = -1;
                }
            }
        }
    }
    
    const colors = ['#ef4444', '#3b82f6', '#22c55e', '#f59e0b', '#a855f7'];
    annotations.forEach((a, idx) => {
        const color = colors[idx % colors.length];
        
        // â˜… v5.6: ëª¨ë“  í´ë¦¬ê³¤ ë Œë”ë§
        if (a.segmentation && a.segmentation.length > 0) {
            for (const seg of a.segmentation) {
                if (seg.length >= 6) {
                    ctx.fillStyle = color + '40';
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2 / scale;
                    
                    ctx.beginPath();
                    ctx.moveTo(seg[0], seg[1]);
                    for (let i = 2; i < seg.length; i += 2) {
                        ctx.lineTo(seg[i], seg[i + 1]);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
        
        const [bx, by, bw, bh] = a.bbox;
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5 / scale;
        ctx.setLineDash([4 / scale, 4 / scale]);
        ctx.strokeRect(bx, by, bw, bh);
        ctx.setLineDash([]);
        
        ctx.fillStyle = color;
        ctx.font = `bold ${11 / scale}px system-ui`;
        const label = a.regionCount > 1 
            ? `${idx + 1}: ${a.category_name} (${a.regionCount}ê°œ)`
            : `${idx + 1}: ${a.category_name}`;
        ctx.fillText(label, bx, by - 4 / scale);
    });
    
    if (tempBbox) {
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([6 / scale, 4 / scale]);
        ctx.strokeRect(tempBbox.x, tempBbox.y, tempBbox.w, tempBbox.h);
        ctx.setLineDash([]);
    }
    
    if (currentBbox) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2 / scale;
        ctx.strokeRect(currentBbox.x, currentBbox.y, currentBbox.w, currentBbox.h);
        ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
        ctx.fillRect(currentBbox.x, currentBbox.y, currentBbox.w, currentBbox.h);
        
        const handleSize = 8 / scale;
        const handles = getBboxHandles(currentBbox, handleSize);
        ctx.fillStyle = '#3b82f6';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1 / scale;
        for (const h of handles) {
            ctx.fillRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
            ctx.strokeRect(h.x - handleSize/2, h.y - handleSize/2, handleSize, handleSize);
        }
    }
    
    ctx.restore();
}

// ============================================================
// ì €ì¥
// ============================================================
async function saveCurrentImage() {
    if (!currentImageData) {
        toast('ì €ì¥í•  ì´ë¯¸ì§€ ì—†ìŒ', 'error');
        return;
    }
    
    if (annotations.length === 0) {
        toast('ì™„ì„±ëœ annotationì´ ì—†ìŠµë‹ˆë‹¤', 'error');
        return;
    }
    
    const domain = document.getElementById('domainSelect').value;
    if (!domain) {
        toast('ë„ë©”ì¸ì„ ì„ íƒí•˜ì„¸ìš”', 'error');
        return;
    }
    
    document.getElementById('loading').classList.add('show');

    try {
        let result;

        if (isServerImage) {
            // â”€â”€ ì„œë²„ ì´ë¯¸ì§€: /save/existing ì‚¬ìš© (íŒŒì¼ ì—…ë¡œë“œ ì—†ìŒ) â”€â”€
            const payload = {
                file_name: serverImageFilename,
                category: serverImageCategory,
                width: imgW,
                height: imgH,
                annotations: annotations.map(a => ({
                    category_id: a.category_id,
                    bbox: a.bbox,
                    segmentation: a.segmentation,
                    area: a.area,
                    iscrowd: 0
                }))
            };
            const res = await fetch('/save/existing', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            result = await res.json();
        } else {
            // â”€â”€ ì—…ë¡œë“œ ì´ë¯¸ì§€: ê¸°ì¡´ /save ì‚¬ìš© â”€â”€
            const b64 = currentImageData.split(',')[1];
            const binary = atob(b64);
            const bytes = new Uint8Array(binary.length);
            for (let j = 0; j < binary.length; j++) {
                bytes[j] = binary.charCodeAt(j);
            }
            const blob = new Blob([bytes], { type: 'image/jpeg' });

            const formData = new FormData();
            formData.append('image', blob, currentFileName);
            formData.append('domain', domain);
            formData.append('width', imgW);
            formData.append('height', imgH);
            formData.append('annotations', JSON.stringify(annotations.map(a => ({
                category_id: a.category_id,
                bbox: a.bbox,
                segmentation: a.segmentation,
                area: a.area,
                iscrowd: 0
            }))));
            const res = await fetch('/save', { method: 'POST', body: formData });
            result = await res.json();
        }

        if (!result.success) throw new Error(result.error);

        savedImages.push({
            file_name: result.file_name,
            image_id: result.image_id,
            anno_count: annotations.length,
            domain: domain,
            timestamp: new Date().toLocaleTimeString('ko-KR')
        });

        toast(`âœ“ ì €ì¥: ${result.file_name} (${annotations.length}ê°œ)`, 'success');
        loadServerInfo();

        // ìƒíƒœ ì´ˆê¸°í™”
        currentImageData = null;
        currentFileName = null;
        isServerImage = false;
        serverImageFilename = null;
        img = null;
        imgW = 0; imgH = 0;
        mask = null; currentBbox = null;
        annotations = []; undoStack = [];

        document.getElementById('fileInfo').style.display = 'none';
        document.getElementById('serverImageInfo').style.display = 'none';
        document.getElementById('fileInput').value = '';

        updateAll();
        render();
        switchTab('saved');

    } catch (e) {
        toast('ì €ì¥ ì˜¤ë¥˜: ' + e.message, 'error');
    } finally {
        document.getElementById('loading').classList.remove('show');
    }
}

// ============================================================
// ì‚­ì œ ê¸°ëŠ¥
// ============================================================
function requestDelete(idx) {
    deleteTarget = idx;
    const item = savedImages[idx];
    document.getElementById('deleteFileName').textContent = item.file_name;
    document.getElementById('deleteModal').classList.add('show');
}

function closeDeleteModal() {
    deleteTarget = null;
    document.getElementById('deleteModal').classList.remove('show');
}

async function confirmDelete() {
    if (deleteTarget === null) return;
    
    const item = savedImages[deleteTarget];
    const elem = document.getElementById(`saved-${deleteTarget}`);
    if (elem) elem.classList.add('deleting');
    
    closeDeleteModal();
    document.getElementById('loading').classList.add('show');
    
    try {
        const res = await fetch('/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                file_name: item.file_name,
                image_id: item.image_id,
                category: item.domain || null
            })
        });
        
        const result = await res.json();
        
        if (!result.success) throw new Error(result.error);
        
        savedImages.splice(deleteTarget, 1);
        
        toast(`âœ“ ì‚­ì œë¨: ${item.file_name}`, 'success');
        loadServerInfo();
        updateSavedList();
        
    } catch (e) {
        toast('ì‚­ì œ ì˜¤ë¥˜: ' + e.message, 'error');
        if (elem) elem.classList.remove('deleting');
    } finally {
        document.getElementById('loading').classList.remove('show');
        deleteTarget = null;
    }
}

// ============================================================
// JSON ë‹¤ìš´ë¡œë“œ
// ============================================================
function downloadJson() {
    if (!currentImageData || annotations.length === 0) {
        toast('ë°ì´í„° ì—†ìŒ', 'error');
        return;
    }
    
    const data = {
        images: [{
            id: 1,
            file_name: currentFileName,
            width: imgW,
            height: imgH
        }],
        annotations: annotations.map((a, i) => ({
            id: i + 1,
            image_id: 1,
            category_id: a.category_id,
            bbox: a.bbox,
            segmentation: a.segmentation,
            area: a.area,
            iscrowd: 0
        })),
        categories: {{ ALL_CATEGORIES | safe }}
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = currentFileName.replace(/\.[^.]+$/, '') + '_annotations.json';
    a.click();
    
    toast('JSON ë‹¤ìš´ë¡œë“œë¨', 'success');
}

function toast(msg, type = 'info') {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.className = 'toast show ' + type;
    setTimeout(() => t.className = 'toast', 2500);
}
</script>
</body>
</html>